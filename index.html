<!--
  This is a self-contained HTML file for a responsive 3D "Cards Stack Slider" carousel.
  It uses Tailwind CSS for styling and JavaScript for functionality.
  This version features:
  - A frameless, full-screen layout.
  - Optimized performance by only rendering a small number of cards at a time.
  - 100 dynamically generated cards with subtle random rotations.
  - A smooth "go back" animation for the swiped card, sending it to the back of the deck.
  - A cyclical, drag-in-any-direction interaction.
  - A compact, single-line timer with a new, sentimental text.
-->
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Cards Stack Slider</title>
    <!-- Google Font -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Patrick+Hand&display=swap" rel="stylesheet">
    <!-- Tailwind CSS CDN for styling -->
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* Custom CSS for the carousel effect */


        @keyframes heartbeat {
        0%   { transform: scale(1); }
        14%  { transform: scale(1.3); }
        28%  { transform: scale(1); }
        42%  { transform: scale(1.2); }
        70%  { transform: scale(1); }
        100% { transform: scale(1); }
        }

        .heartbeat {
        display: inline-block;            /* <-- important */
        transform-origin: center center;  /* nicer scaling */
        animation: heartbeat 1.25s ease-in-out infinite;
        }


        body {
            background-color: #f4d0df; /* A baby pink background */
        }
        .carousel-container {
            position: relative;
            width: 52.5vw; /* Responsive width */
            height: 26.25vw; /* Responsive height, maintains aspect ratio */
        }
        .carousel-track {
            position: relative;
            width: 100%;
            height: 100%;
            touch-action: none; /* Prevents all default touch actions on the track */
        }
        .carousel-slide {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            transform-origin: center;
            transition: transform 0.5s ease-out, opacity 0.5s ease-out;
            box-shadow: 0 8px 30px rgba(0, 0, 0, 0.1); /* Soft drop shadow */
        }

        .carousel-slide::before {
            content: "";
            position: absolute;
            inset: 0;
            border-radius: 1rem;
            backdrop-filter: blur(8px); /* Glassy background effect */
            -webkit-backdrop-filter: blur(8px);
        }

        .cute-font {
            font-family: 'Patrick Hand', cursive;
        }
        .card-text {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 90%;
            height: 90%;
            display: flex;
            align-items: center;
            justify-content: center;
            text-align: center;
            color: #ffffff;
            font-weight: regular;
            line-height: 1.2;
            word-wrap: break-word;
            padding: 1rem;
            box-sizing: border-box;
            background-color: rgba(0,0,0,0.0);
            border-radius: 1rem;
            -webkit-backdrop-filter: blur(5px);
            backdrop-filter: blur(5px);
        }
    </style>
</head>
<body class="flex items-center justify-center min-h-screen p-4 font-sans flex-col">
    <div class="carousel-container">
        <div id="carousel-track" class="carousel-track">
            <!-- Cards will be dynamically added here by JavaScript -->
        </div>
    </div>
    
    <!-- Timer Display -->
    <div class="mt-8 text-center cute-font text-lg">
        <span class="text-pink-500">Thank you loveee, for loving me for </span>
        <span id="timer" class="text-pink-500"></span>
        <span class="heartbeat text-pink-500"> &lt;3 </span>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            const track = document.getElementById('carousel-track');
            const timerDisplay = document.getElementById('timer');
            
            // --- Core Carousel Logic ---
            
            // Define your custom text messages here
            const customTexts = [
                "''26 Things I Love Ab You''",
                "I love your pearly eyes",
                "I love the way you smile",
                "I love how you make me feel",
                "I love the way you say ''you're miNeee'' :3",
                "I love the way you call me ''Nee''",
                "I love how you put my sorrows away",
                "I love how you make me feel free",
                "mygoddd I love your hairs by the wayyyy :3",
                "I love your pretty little face",
                "I love your warm, gentle embrace",
                "I love the way you say ''Hello''",
                "I love your ''I love you'', whispered low",      
                "I love the way you singg",
                "I love your pretty earring",
                "I love the way you say ''Eiii'' out loud",
                "Being loved my you makes me sooo proud :3",
                "I love your cute Vampire Teeth",
                "I listen to your songs on repeat",
                "I love how you type with extra e's",
                "God knows how much I crave for your kiss :333",
                "Thanks Jaan, for teaching me what is love",
                "You and only you are my beloved",
                "I won't ever give up on you",
                "Never never never",
                "I love you and I'll love you",
                "Forever ever and everrrrr",
                "Hehe :3",
                // Add more custom messages here!
                // The carousel will automatically adjust its card count.
            ];

            const cardCount = customTexts.length; // Use the length of your custom array
            const maxCardsInDom = 5; 
            
            let currentSlideIndex = 0; 
            let slides = []; 
            let rotations = []; 
            const colors = ['#fc6c85','#fb6f92', '#ff8fab','#fb6f92'];

            // Initialize rotations for all 100 cards
            for (let i = 0; i < cardCount; i++) {
                rotations.push(Math.random() * 4 - 2); // Random rotation between -2 and 2 degrees
            }

            // Function to get the color for a specific card index
            const getCardColor = (index) => {
                return colors[index % colors.length];
            };

            // Dynamic text resizing function
        const resizeText = (textEl) => {
            // Resize text so it fills ~85% of card height and 90% of card width
            const resizeText = (textEl) => {
            const parent = textEl.parentElement;
            let fontSize = 10; // start small
            textEl.style.fontSize = `${fontSize}px`;

            const maxHeight = parent.clientHeight * 0.9;
            const maxWidth = parent.clientWidth * 0.9;

            // Grow until we hit the limit
            while (
                textEl.scrollHeight <= maxHeight &&
                textEl.scrollWidth <= maxWidth &&
                fontSize < 100
            ) {
                fontSize += 10;
                textEl.style.fontSize = `${fontSize}px`;
            }

            // Step back one so it doesn't overflow
            textEl.style.fontSize = `${fontSize - 1}px`;
        };

            };

            // Renders and updates the cards in the DOM based on the current slide index
            const renderCards = () => {
                track.innerHTML = '';
                slides = [];

                let startIndex = currentSlideIndex;
                let cardsToRender = [];
                for (let i = 0; i < maxCardsInDom; i++) {
                    const cardIndex = (startIndex + i + cardCount) % cardCount;
                    cardsToRender.push(cardIndex);
                }

                cardsToRender.forEach((cardIndex, domIndex) => {
                    const newSlide = document.createElement('div');
                    newSlide.classList.add('carousel-slide');
                    if (domIndex === 0) {
                        newSlide.classList.add('active');
                    }
                    newSlide.dataset.cardIndex = cardIndex;
                    const cardText = customTexts[cardIndex];
                    const cardTextHtml = cardText.replace(/\n/g, '<br>');
                    newSlide.style.backgroundColor = getCardColor(cardIndex); // Set background color
                    newSlide.innerHTML = `<div class="card-text cute-font">${cardTextHtml}</div>`;
                    track.appendChild(newSlide);
                    slides.push(newSlide);
                });
                
                updateCarousel(false);
            };
            
            const updateCarousel = (animate = true) => {
                slides.forEach((slide, domIndex) => {
                    const cardIndex = parseInt(slide.dataset.cardIndex);
                    
                    let translateX = 0;
                    let translateY = 0;
                    let zIndex = 0;
                    let opacity = 1;
                    let rotate = 0;

                    const distance = (cardIndex - currentSlideIndex + cardCount) % cardCount;

                    if (distance === 0) {
                        translateX = 0;
                        translateY = 0;
                        zIndex = 100;
                        opacity = 1;
                        rotate = rotations[cardIndex];
                        slide.classList.add('active');
                    } else {
                        const offset = 1.5 * distance;
                        translateX = -offset;
                        translateY = offset;
                        zIndex = 100 - distance;
                        opacity = 1;
                        rotate = rotations[cardIndex];
                        slide.classList.remove('active');
                    }

                    if (animate) {
                        slide.style.transition = 'transform 0.5s ease-out, opacity 0.5s ease-out';
                    } else {
                        slide.style.transition = 'none';
                    }
                    
                    slide.style.transform = `translateX(${translateX}px) translateY(${translateY}px) rotateZ(${rotate}deg)`;
                    slide.style.zIndex = zIndex;
                    slide.style.opacity = opacity;

                    const textElement = slide.querySelector('.card-text');
                    if (textElement) {
                        resizeText(textElement);
                    }
                });
            };

            const advanceCard = () => {
                currentSlideIndex = (currentSlideIndex + 1) % cardCount;
                renderCards();
            };

            const goBackCard = () => {
                currentSlideIndex = (currentSlideIndex - 1 + cardCount) % cardCount;
                renderCards();
            };
            
            let isDragging = false;
            let startX = 0;
            let startY = 0;
            let dragDistanceX = 0;
            let dragDistanceY = 0;
            const swipeThreshold = 50;

            const dragCarousel = (dragDistanceX, dragDistanceY) => {
                slides.forEach((slide, domIndex) => {
                    const cardIndex = parseInt(slide.dataset.cardIndex);
                    
                    if (domIndex === 0) {
                        slide.style.transition = 'none';
                        slide.style.transform = `translateX(${dragDistanceX}px) translateY(${dragDistanceY}px) rotateZ(${rotations[cardIndex]}deg)`;
                        slide.style.zIndex = 100;
                    } else {
                        slide.style.transition = 'none';
                        const stackingOffset = 1.5;
                        const distance = (cardIndex - currentSlideIndex + cardCount) % cardCount;
                        const newOffsetX = -stackingOffset * distance;
                        const newOffsetY = stackingOffset * distance;
                        slide.style.transform = `translateX(${newOffsetX}px) translateY(${newOffsetY}px) rotateZ(${rotations[cardIndex]}deg)`;
                        slide.style.zIndex = 100 - distance;
                    }
                });
            };


            track.addEventListener('pointerdown', (e) => {
                e.preventDefault();
                isDragging = true;
                track.classList.add('dragging');
                track.setPointerCapture(e.pointerId);
                startX = e.clientX;
                startY = e.clientY;
            });

            track.addEventListener('pointermove', (e) => {
                if (!isDragging) return;
                e.preventDefault();
                dragDistanceX = e.clientX - startX;
                dragDistanceY = e.clientY - startY;

                dragCarousel(dragDistanceX, dragDistanceY);

                const activeSlide = slides[0];
                const dragMagnitude = Math.sqrt(dragDistanceX * dragDistanceX + dragDistanceY * dragDistanceY);
                const fadeDistance = 200;
                const newOpacity = Math.max(0, 1 - (dragMagnitude / fadeDistance));
                activeSlide.style.opacity = newOpacity;
            });

            track.addEventListener('pointerup', (e) => {
                if (!isDragging) return;
                isDragging = false;
                track.classList.remove('dragging');
                
                const dragMagnitude = Math.sqrt(dragDistanceX * dragDistanceX + dragDistanceY * dragDistanceY);

                if (dragMagnitude > swipeThreshold) {
                    const oldActiveSlide = slides[0];
                    let nextIndex = (currentSlideIndex + 1) % cardCount;

                    oldActiveSlide.style.transition = 'transform 0.5s ease-out, opacity 0.5s ease-out';
                    oldActiveSlide.style.zIndex = 100 - (maxCardsInDom + 1);
                    oldActiveSlide.style.opacity = 1;
                    const offset = 1.5 * (maxCardsInDom + 1);
                    oldActiveSlide.style.transform = `translateX(${-offset}px) translateY(${offset}px) rotateZ(${rotations[parseInt(oldActiveSlide.dataset.cardIndex)]}deg)`;
                    
                    currentSlideIndex = nextIndex;
                    
                    oldActiveSlide.addEventListener('transitionend', () => {
                        renderCards();
                    }, { once: true });
                } else {
                    updateCarousel(true);
                }

                dragDistanceX = 0;
                dragDistanceY = 0;
            });

            const startDate = new Date('2025-05-14T22:49:00');

            function updateTimer() {
                const now = new Date();
                const diff = now.getTime() - startDate.getTime();

                const days = Math.floor(diff / (1000 * 60 * 60 * 24));
                const hours = Math.floor((diff % (1000 * 60 * 60 * 24)) / (1000 * 60 * 60));
                const minutes = Math.floor((diff % (1000 * 60 * 60)) / (1000 * 60));
                const seconds = Math.floor((diff % (1000 * 60)) / 1000);
                
                timerDisplay.innerHTML = `${days}d ${hours}h ${minutes}m ${seconds}s`;
            }

            renderCards();
            updateTimer();
            setInterval(updateTimer, 1000);
            window.addEventListener('resize', updateCarousel);
        });
    </script>
</body>
</html>
